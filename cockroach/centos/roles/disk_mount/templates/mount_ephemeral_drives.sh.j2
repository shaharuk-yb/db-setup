#!/bin/bash
set -euo pipefail

readonly CLOUD_TYPE="{{ cloud_type }}"
readonly DEFAULT_SSD_DRIVES="{{ device_paths }}"
readonly MOUNT_PATHS="{{ mount_paths }}"

should_check_aws_meta() {
  [[ -z $DEFAULT_SSD_DRIVES && $CLOUD_TYPE == "aws" ]]
}


# arg: ephemeral
get_device_path() {
  local ephemeral_name=$1
  local output=
    output=$ephemeral_name
  get_device_path_rv="/dev/$output"
}

get_ephemeral_drives() {
  get_ephemeral_drives_rv=$DEFAULT_SSD_DRIVES
}

# Starting a block whose output will be redirected to syslog.
(
  declare -i exit_code=0

  # Take into account xvdb or sdb
  root_drive=$(lsblk | awk '$7 == "/" {print $1}' | tr -cd '[:alnum:]/')

  if [[ "$root_drive" =~ .*xvd.* ]]; then
    echo "Detected 'xvd' drive naming scheme (root: $root_drive)"
    DRIVE_SCHEME='xvd'
  elif [[ "$root_drive" =~ .*nvme.* ]]; then
    echo "Detected 'nvme' drive naming scheme (root: $root_drive)"
    DRIVE_SCHEME='nvme'
  else
    echo "Detected 'sd' drive naming scheme (root: $root_drive)"
    DRIVE_SCHEME='sd'
  fi

  get_ephemeral_drives
  ephemerals=( $get_ephemeral_drives_rv )

  {% raw %}
  num_devices=${#ephemerals[@]}

  if [[ $num_devices -eq 0 ]]; then
    echo "Found no volumes to mount"
    exit
  fi

  echo "============================"
  echo "Drives supporting SSDs:"
  echo "${ephemerals[@]}"
  echo "============================"

  # For old generation aws instances, we assume YugaWare requests a number of ephemerals appropriate
  # to the instance type. E.g. m3.medium only supports 1 ephemeral, but m3.xlarge supports 2.
  mounts=( $MOUNT_PATHS )

  if [[ ${#mounts[@]} -eq 0 ]]; then
    echo >&2 "No mount points provided, cannot mount any devices."
    exit 1
  fi

  if [[ ${#mounts[@]} -lt $num_devices ]]; then
    echo >&2 "Only ${#mounts[@]} mount points provided: $MOUNT_PATHS, but num_devices=$num_devices."
    declare -i num_devices=${#mounts[@]}
    echo >&2 "Will only mount $num_devices volumes, and return an error after that."
    exit_code=1
  fi

  declare -g eph_idx=0
  # iterate through 1 more than num_devices to skip over root volume
  for (( i=0; i<num_devices+1; ++i )); do
    e=${ephemerals[eph_idx]}
    echo "Probing $e ..."
    # Some instance types (C5, M5 etc) have EBS volume mounted as nvme
    # In which case we want to make the device path to match that
    # https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nvme-ebs-volumes.html
    if [[ "$DRIVE_SCHEME" == "nvme" ]]; then
        device_idx=$((i))
        device_path="/dev/nvme${device_idx}n1"
    else
        get_device_path "$e"
        device_path=$get_device_path_rv

        # If needed, convert 'sdb' -> 'xvdb'
        device_path=$(echo $device_path | sed "s/sd/$DRIVE_SCHEME/")
    fi

    # Test that the device actually exists since you can request more ephemeral drives than are
    # available for an instance type and the meta-data API will happily tell you it exists when it
    # really does not.
    # Also check to make sure we don't try to mount on root volume
    if [ -b "$device_path" ] && ! grep -q "$device_path" <<< "/dev/${root_drive}"; then
      echo "Detected ephemeral disk: $device_path"
      set +e
      # NOTE: This does not seem to return the actual file system
      file_system=$(/sbin/blkid -o value -s TYPE -c /dev/null $device_path)
      blkid_error=$?
      set -e
      # On some EC2 instance types (e.g., i2.4xlarge), the above command or fdisk doesn't discover
      # the drive correctly. It in turn returns an exit code of 2 indicating that the drive was not
      # found.  In that case, we go ahead and create XFS on that drive.
      if [[ $blkid_error -ne 0 && $blkid_error -ne 2 ]]; then
        echo "blkid returned exit code $blkid_error for $device_path"
        exit 1
      fi
      if [[ $blkid_error -eq 2 || $file_system != xfs ]]; then
        if [[ -f /sbin/mkfs.xfs ]]; then
          echo "Creating xfs on: " $device_path
          /sbin/mkfs.xfs $device_path -f
          file_system=xfs
        else
          echo "mkfs.xfs not found. Using the default - $file_system"
        fi
      fi

      mount_path=${mounts[$eph_idx]}

      mkdir -p "$mount_path"
      chmod 777 "$mount_path"

      device_uuid=$(/sbin/blkid -o value -s UUID -c /dev/null $device_path)
      echo "device uuid = $device_uuid"

      if grep -q "#$mount_path" /etc/fstab; then
        echo "Entry for $mount_path in fstab already exists."
        if egrep -q "^$device_path .*" /etc/fstab; then
          echo "Device $device_path is mounted not using UUID, need to rewrite"
          sed -i "s|^$device_path |UUID=$device_uuid |g" /etc/fstab
        fi
      else
        echo "Adding entry for $mount_path to fstab..."
        echo "#$mount_path" >> /etc/fstab
        # Mounting using UUID
        echo "UUID=$device_uuid $mount_path $file_system defaults,noatime,nofail,allocsize=4m 0 2" \
                        >> /etc/fstab
      fi
      echo "checking actual path"
      already_mounted=false
      # Sometimes link does not exist at the time of checking
      if test -e "/dev/disk/by-uuid/$device_uuid"; then
        actual_path=$(readlink -eq "/dev/disk/by-uuid/$device_uuid")
        echo "actual_path is $actual_path"
        mount | egrep -q "^$actual_path on $mount_path " && already_mounted=true
      fi
      if $already_mounted; then
        echo "$device_path is already mounted on $mount_path"
      else
        echo "Mounting $device_path on $mount_path"
        ( set -x; mount $mount_path )
      fi
      # The first time we mount the drives, the permissions seem to flip back to 755. Perhaps,
      # there's a better way to set the permissions in fstab itself. But couldn't find one that
      # works. For now, updating the permissions again. On subsequent mount/umounts, this problem
      # does not happen. So we are covered on that front (e.g. as might happen during a reboot).
      chmod 777 $mount_path
      # only increment ephemeral index when mount path is used for a device
      eph_idx=$((eph_idx+1))
      # break when we are done with all mounts
      if [ "$eph_idx" = "$num_devices" ]; then
        break
      fi
    else
      echo "Ephemeral disk $e, $device_path is not present or part of root $root_drive. Skipping."
    fi
  done

  exit $exit_code

  {% endraw %}

) 2>&1 | logger -t "${0##*/}"
